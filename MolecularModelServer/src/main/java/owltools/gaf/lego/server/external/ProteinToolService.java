package owltools.gaf.lego.server.external;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.semanticweb.owlapi.model.IRI;
import org.semanticweb.owlapi.model.OWLClass;
import org.semanticweb.owlapi.model.OWLOntology;
import org.semanticweb.owlapi.model.OWLOntologyCreationException;

import owltools.gaf.bioentities.ProteinTools;
import owltools.graph.OWLGraphWrapper;
import owltools.io.CatalogXmlIRIMapper;
import owltools.io.ParserWrapper;
import owltools.vocab.OBOUpperVocabulary;

/**
 * Load a folder of Protein ontologies for lookup as generated by {@link ProteinTools}.
 */
public class ProteinToolService implements ExternalLookupService {
	
	final Set<IRI> obsoleteIRIs;
	final Map<String, List<LookupEntry>> proteinEntryMap;

	public ProteinToolService(String proteinOntologyFolder) throws IOException {
		proteinEntryMap = new HashMap<String, List<LookupEntry>>();
		File catalogXml = new File(proteinOntologyFolder, "catalog-v001.xml");
		CatalogXmlIRIMapper mapper = new CatalogXmlIRIMapper(catalogXml);
		obsoleteIRIs = new HashSet<IRI>(mapper.getMappings().keySet());
		ParserWrapper pw = new ParserWrapper();
		pw.addIRIMapper(mapper);
		final IRI proRootIRI = IRI.create(OBOUpperVocabulary.OBO+"PR_000000001");
		for (IRI ontologyIri : obsoleteIRIs) {
			String taxonId = getTaxonId(ontologyIri);
			try {
				OWLOntology owl = pw.parseOWL(ontologyIri);
				OWLGraphWrapper g = new OWLGraphWrapper(owl);
				Set<OWLClass> proteins = owl.getClassesInSignature();
				for (OWLClass protein : proteins) {
					// skip root
					if (proRootIRI.equals(protein.getIRI())) {
						continue;
					}
					// get label and id
					String label = g.getLabel(protein);
					String id = g.getIdentifier(protein);
					if (label != null && id != null) {
						LookupEntry entry = new LookupEntry(id, label, "protein", taxonId);
						List<LookupEntry> entries = proteinEntryMap.get(id);
						if (entries == null) {
							entries = new ArrayList<LookupEntry>();
							proteinEntryMap.put(id, entries);
						}
						entries.add(entry);
					}
					
				}
			} catch (OWLOntologyCreationException e) {
				throw new IOException("Could not load IRI: "+ontologyIri, e);
			}
		}
	}
	
	private static String getTaxonId(IRI ontologyIRI) {
		String iriString = ontologyIRI.toString();
		String s = StringUtils.removeEnd(iriString, ".owl");
		s = StringUtils.removeStart(s, OBOUpperVocabulary.OBO+"go/protein/subset/");
		return s;
		
	}
	
	public Set<IRI> getOntologyIRIs() {
		return obsoleteIRIs;
	}

	@Override
	public List<LookupEntry> lookup(String id) {
		List<LookupEntry> entries = proteinEntryMap.get(id);
		if (entries == null) {
			entries = Collections.emptyList();
		}
		return entries;
	}

	@Override
	public LookupEntry lookup(String id, String taxon) {
		LookupEntry entry = null;
		List<LookupEntry> list = proteinEntryMap.get(id);
		for (LookupEntry current : list) {
			if (taxon.equals(current.taxon)) {
				entry = current;
				break;
			}
		}
		return entry;
	}

}
